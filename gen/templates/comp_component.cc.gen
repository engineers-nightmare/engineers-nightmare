/* THIS FILE IS AUTOGENERATED BY gen/gen_comps.py; DO NOT HAND-MODIFY */

#include <algorithm>
#include <string.h>
#include <memory>

#include "../memory.h"
#include "${comp_name}_component.h"
#include "component_system_manager.h"

extern component_system_manager component_system_man;

void
${comp_name}_component_manager::create_component_instance_data(unsigned count) {
    if (count <= buffer.allocated)
        return;

    component_buffer new_buffer{};
    instance_data new_pool{};

    size_t size = sizeof(c_entity) * count;
% for body in comp.body_fields:
    size = sizeof(${body['type']}) * count + align_size<${body['type']}>(size);
% endfor
    size += 16;   // for worst-case misalignment of initial ptr

    new_buffer.buffer = malloc(size);
    new_buffer.num = buffer.num;
    new_buffer.allocated = count;
    memset(new_buffer.buffer, 0, size);

    new_pool.entity = align_ptr((c_entity *)new_buffer.buffer);
% for body in comp.body_fields:
    new_pool.${body['name']} = align_ptr((${body['type']} *)(new_pool.${body['prev']} + count));
% endfor

    memcpy(new_pool.entity, instance_pool.entity, buffer.num * sizeof(c_entity));
% for body in comp.body_fields:
    memcpy(new_pool.${body['name']}, instance_pool.${body['name']}, buffer.num * sizeof(${body['type']}));
% endfor

    free(buffer.buffer);
    buffer = new_buffer;

    instance_pool = new_pool;
}

void
${comp_name}_component_manager::destroy_instance(instance i) {
    auto last_index = buffer.num - 1;
    auto last_entity = instance_pool.entity[last_index];
    auto current_entity = instance_pool.entity[i.index];

    instance_pool.entity[i.index] = instance_pool.entity[last_index];
% for body in comp.body_fields:
    instance_pool.${body['name']}[i.index] = instance_pool.${body['name']}[last_index];
% endfor

    entity_instance_map[last_entity] = i.index;
    entity_instance_map.erase(current_entity);

    --buffer.num;
}

void
${comp_name}_component_manager::entity(c_entity e) {
    if (buffer.num >= buffer.allocated) {
        printf("Increasing size of ${comp_name} buffer. Please adjust\n");
        create_component_instance_data(std::max(1u, buffer.allocated) * 2);
    }

    auto inst = lookup(e);

    instance_pool.entity[inst.index] = e;
}

void
${comp_name}_component_stub::assign_component_to_entity(c_entity entity) {
    auto &man = component_system_man.managers.${comp_name}_component_man;

    man.assign_entity(entity);

% if comp.body_fields:
    auto data = man.get_instance_data(entity);
% endif

% for body in comp.body_fields:
    % if body['stub']:
    *data.${body['stub']['name']} = ${body['stub']['pre']}${body['stub']['name']}${body['stub']['extra']};
    % else:
    *data.${body['name']} = ${body['default']};
    % endif
% endfor
};

std::unique_ptr<component_stub> ${comp_name}_component_stub::from_config(const config_setting_t *config) {
    auto ${comp_name}_stub = std::make_unique<${comp_name}_component_stub>();

% for stub in comp.stub_fields:
    ${comp_name}_stub->${stub['name']} = load_value_from_config<${stub['type']}>(config, "${stub['name']}");
% endfor

    return std::move(${comp_name}_stub);
}

std::vector<std::string> ${comp_name}_component_stub::get_dependencies() {
    return {
% for dep in comp.dependencies:
        "${dep}",
% endfor
    };
}
