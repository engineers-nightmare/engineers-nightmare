/* THIS FILE IS AUTOGENERATED BY gen/gen_comps.py; DO NOT HAND-MODIFY */

#include <algorithm>
#include <string.h>
#include <memory>

#include "../memory.h"
#include "rotator_stepped_component.h"
#include "component_system_manager.h"

extern component_system_manager component_system_man;

void
rotator_stepped_component_manager::create_component_instance_data(unsigned count) {
    if (count <= buffer.allocated)
        return;

    component_buffer new_buffer{};
    instance_data new_pool{};

    size_t size = sizeof(c_entity) * count;
    size = sizeof(wire_filter_ptr) * count + align_size<wire_filter_ptr>(size);
    size = sizeof(wire_filter_ptr) * count + align_size<wire_filter_ptr>(size);
    size = sizeof(wire_filter_ptr) * count + align_size<wire_filter_ptr>(size);
    size = sizeof(glm::vec3) * count + align_size<glm::vec3>(size);
    size = sizeof(glm::vec3) * count + align_size<glm::vec3>(size);
    size = sizeof(float) * count + align_size<float>(size);
    size = sizeof(float) * count + align_size<float>(size);
    size = sizeof(float) * count + align_size<float>(size);
    size = sizeof(float) * count + align_size<float>(size);
    size = sizeof(bool) * count + align_size<bool>(size);
    size += 16;   // for worst-case misalignment of initial ptr

    new_buffer.buffer = malloc(size);
    new_buffer.num = buffer.num;
    new_buffer.allocated = count;
    memset(new_buffer.buffer, 0, size);

    new_pool.entity = align_ptr((c_entity *)new_buffer.buffer);
    new_pool.step_up = align_ptr((wire_filter_ptr *)(new_pool.entity + count));
    new_pool.step_down = align_ptr((wire_filter_ptr *)(new_pool.step_up + count));
    new_pool.value_driver = align_ptr((wire_filter_ptr *)(new_pool.step_down + count));
    new_pool.axis = align_ptr((glm::vec3 *)(new_pool.value_driver + count));
    new_pool.offset = align_ptr((glm::vec3 *)(new_pool.axis + count));
    new_pool.speed = align_ptr((float *)(new_pool.offset + count));
    new_pool.step_size = align_ptr((float *)(new_pool.speed + count));
    new_pool.angle = align_ptr((float *)(new_pool.step_size + count));
    new_pool.desired_angle = align_ptr((float *)(new_pool.angle + count));
    new_pool.continuous = align_ptr((bool *)(new_pool.desired_angle + count));

    memcpy(new_pool.entity, instance_pool.entity, buffer.num * sizeof(c_entity));
    memcpy(new_pool.step_up, instance_pool.step_up, buffer.num * sizeof(wire_filter_ptr));
    memcpy(new_pool.step_down, instance_pool.step_down, buffer.num * sizeof(wire_filter_ptr));
    memcpy(new_pool.value_driver, instance_pool.value_driver, buffer.num * sizeof(wire_filter_ptr));
    memcpy(new_pool.axis, instance_pool.axis, buffer.num * sizeof(glm::vec3));
    memcpy(new_pool.offset, instance_pool.offset, buffer.num * sizeof(glm::vec3));
    memcpy(new_pool.speed, instance_pool.speed, buffer.num * sizeof(float));
    memcpy(new_pool.step_size, instance_pool.step_size, buffer.num * sizeof(float));
    memcpy(new_pool.angle, instance_pool.angle, buffer.num * sizeof(float));
    memcpy(new_pool.desired_angle, instance_pool.desired_angle, buffer.num * sizeof(float));
    memcpy(new_pool.continuous, instance_pool.continuous, buffer.num * sizeof(bool));

    free(buffer.buffer);
    buffer = new_buffer;

    instance_pool = new_pool;
}

void
rotator_stepped_component_manager::destroy_instance(instance i) {
    auto last_index = buffer.num - 1;
    auto last_entity = instance_pool.entity[last_index];
    auto current_entity = instance_pool.entity[i.index];

    instance_pool.entity[i.index] = instance_pool.entity[last_index];
    instance_pool.step_up[i.index] = instance_pool.step_up[last_index];
    instance_pool.step_down[i.index] = instance_pool.step_down[last_index];
    instance_pool.value_driver[i.index] = instance_pool.value_driver[last_index];
    instance_pool.axis[i.index] = instance_pool.axis[last_index];
    instance_pool.offset[i.index] = instance_pool.offset[last_index];
    instance_pool.speed[i.index] = instance_pool.speed[last_index];
    instance_pool.step_size[i.index] = instance_pool.step_size[last_index];
    instance_pool.angle[i.index] = instance_pool.angle[last_index];
    instance_pool.desired_angle[i.index] = instance_pool.desired_angle[last_index];
    instance_pool.continuous[i.index] = instance_pool.continuous[last_index];

    entity_instance_map[last_entity] = i.index;
    entity_instance_map.erase(current_entity);

    --buffer.num;
}

void
rotator_stepped_component_manager::entity(c_entity e) {
    if (buffer.num >= buffer.allocated) {
        printf("Increasing size of rotator_stepped buffer. Please adjust\n");
        create_component_instance_data(std::max(1u, buffer.allocated) * 2);
    }

    auto inst = lookup(e);

    instance_pool.entity[inst.index] = e;
}

void
rotator_stepped_component_stub::assign_component_to_entity(c_entity entity) {
    auto &man = component_system_man.managers.rotator_stepped_component_man;

    man.assign_entity(entity);

    auto data = man.get_instance_data(entity);

    *data.step_up = {};
    *data.step_down = {};
    *data.value_driver = {};
    *data.axis = axis;
    *data.offset = offset;
    *data.speed = speed;
    *data.step_size = step_size;
    *data.angle = 0;
    *data.desired_angle = 0;
    *data.continuous = continuous;
};

std::unique_ptr<component_stub> rotator_stepped_component_stub::from_config(const config_setting_t *config) {
    auto rotator_stepped_stub = std::make_unique<rotator_stepped_component_stub>();

    rotator_stepped_stub->axis = load_value_from_config<glm::vec3>(config, "axis");
    rotator_stepped_stub->offset = load_value_from_config<glm::vec3>(config, "offset");
    rotator_stepped_stub->speed = load_value_from_config<float>(config, "speed");
    rotator_stepped_stub->step_size = load_value_from_config<float>(config, "step_size");
    rotator_stepped_stub->continuous = load_value_from_config<bool>(config, "continuous");

    return std::move(rotator_stepped_stub);
}

std::vector<std::string> rotator_stepped_component_stub::get_dependencies() {
    return {
        "position",
        "parent",
        "wire_comms",
    };
}
